initSidebarItems({"enum":[["Adt","A Data Type"],["AssocItem",""],["BuiltinType",""],["CallableDef",""],["Container",""],["DefWithBody","The defs which have a body."],["DocDef",""],["Either",""],["FieldSource",""],["GenericDef",""],["ModuleDef","The defs which can be visible in the module."],["ModuleSource",""],["Mutability",""],["PathKind",""],["ScopeDef","For IDE only"],["Ty","A type."],["TypeCtor","A type constructor or type name: this might be something like the primitive type `bool`, a struct like `Vec`, or things like function pointers or tuples."],["VariantDef",""]],"mod":[["db","FIXME: write short doc here"],["debug","printf debugging infrastructure for rust-analyzer."],["diagnostics","FIXME: write short doc here"],["from_source","FIXME: write short doc here"],["source_binder","Lookup hir elements using positions in the source code. This is a lossy transformation: in general, a single source might correspond to several modules, functions, etc, due to macros, cfgs and `#[path=]` attributes on modules."]],"struct":[["ApplicationTy","A nominal type with (maybe 0) type parameters. This might be a primitive type like `bool`, a struct, tuple, function pointer, reference or several other things."],["Const",""],["ConstData",""],["Crate","hir::Crate describes a single crate. It's the main interface with which a crate's dependencies interact. Mostly, it should be just a proxy for the root module."],["CrateDependency",""],["Documentation","Holds documentation"],["Enum",""],["EnumVariant",""],["ExprScopes",""],["FnData",""],["Function",""],["GenericParam","Data about a generic parameter (to a function, struct, impl, ...)."],["GenericParams","Data about the generic parameters of a function, struct, impl, etc."],["HirFileId","Input to the analyzer is a set of files, where each file is identified by `FileId` and contains source code. However, another source of source code in Rust are macros: each macro can be thought of as producing a \"temporary file\". To assign an id to such a file, we use the id of the macro call that produced the file. So, a `HirFileId` is either a `FileId` (source code written by user), or a `MacroCallId` (source code produced by macro)."],["ImplBlock",""],["ImportId",""],["MacroCallId","`MacroCallId` identifies a particular macro invocation, like `println!(\"Hello, {}\", world)`."],["MacroCallLoc",""],["MacroDef",""],["MacroDefId",""],["MacroFile",""],["Module",""],["Name","`Name` is a wrapper around string, which is used in hir for both references and declarations. In theory, names should also carry hygiene info, but we are not there yet!"],["Path",""],["PerNs",""],["Source",""],["Static",""],["Struct",""],["StructField",""],["Substs","A list of substitutions for generic parameters."],["Trait",""],["TraitRef","A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait. Name to be bikeshedded: TraitBound? TraitImplements?"],["TypeAlias",""],["Union",""]],"trait":[["Docs",""],["HasBody",""],["HasBodySource",""],["HasGenericParams",""],["HasSource",""],["HirDisplay",""],["TypeWalk","This allows walking structures that contain types to do something with those types, similar to Chalk's `Fold` trait."]]});